<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.2">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>validators – Rømer Chain</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-07c16812f08c4a1591d6ec4fc46327fa.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-ddd961a2510921635943dfbbd19534c4.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">Rømer Chain</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="./index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./pitch/index.html"> 
<span class="menu-text">Pitch Deck</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./pop.html"> 
<span class="menu-text">Proof of Physics</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./tokenomics.html"> 
<span class="menu-text">Tokenomics</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./devnet.html"> 
<span class="menu-text">Devnet</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./economics.html"> 
<span class="menu-text">RØMER’s Economic Model</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link active" href="./validators.html" aria-current="page"> 
<span class="menu-text">Validators</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#rømer-transaction-costs-and-resource-model" id="toc-rømer-transaction-costs-and-resource-model" class="nav-link active" data-scroll-target="#rømer-transaction-costs-and-resource-model">RØMER Transaction Costs and Resource Model</a>
  <ul class="collapse">
  <li><a href="#node-requirements" id="toc-node-requirements" class="nav-link" data-scroll-target="#node-requirements">Node Requirements</a>
  <ul class="collapse">
  <li><a href="#hardware-requirements" id="toc-hardware-requirements" class="nav-link" data-scroll-target="#hardware-requirements">Hardware Requirements</a></li>
  <li><a href="#network-requirements" id="toc-network-requirements" class="nav-link" data-scroll-target="#network-requirements">Network Requirements</a></li>
  </ul></li>
  <li><a href="#computational-fee-model" id="toc-computational-fee-model" class="nav-link" data-scroll-target="#computational-fee-model">Computational Fee Model</a>
  <ul class="collapse">
  <li><a href="#cpu-resources-0.6-rømer-per-block" id="toc-cpu-resources-0.6-rømer-per-block" class="nav-link" data-scroll-target="#cpu-resources-0.6-rømer-per-block">CPU Resources (0.6 RØMER per block)</a></li>
  <li><a href="#ram-resources-0.4-rømer-per-block" id="toc-ram-resources-0.4-rømer-per-block" class="nav-link" data-scroll-target="#ram-resources-0.4-rømer-per-block">RAM Resources (0.4 RØMER per block)</a></li>
  <li><a href="#computational-fee-formula" id="toc-computational-fee-formula" class="nav-link" data-scroll-target="#computational-fee-formula">Computational Fee Formula</a></li>
  </ul></li>
  <li><a href="#storage-model" id="toc-storage-model" class="nav-link" data-scroll-target="#storage-model">Storage Model</a>
  <ul class="collapse">
  <li><a href="#storage-deposits" id="toc-storage-deposits" class="nav-link" data-scroll-target="#storage-deposits">Storage Deposits</a></li>
  <li><a href="#storage-rebates" id="toc-storage-rebates" class="nav-link" data-scroll-target="#storage-rebates">Storage Rebates</a></li>
  </ul></li>
  <li><a href="#example-operation-costs" id="toc-example-operation-costs" class="nav-link" data-scroll-target="#example-operation-costs">Example Operation Costs</a>
  <ul class="collapse">
  <li><a href="#simple-token-transfer" id="toc-simple-token-transfer" class="nav-link" data-scroll-target="#simple-token-transfer">Simple Token Transfer</a></li>
  <li><a href="#nft-mint-operation" id="toc-nft-mint-operation" class="nav-link" data-scroll-target="#nft-mint-operation">NFT Mint Operation</a></li>
  <li><a href="#smart-contract-deployment" id="toc-smart-contract-deployment" class="nav-link" data-scroll-target="#smart-contract-deployment">Smart Contract Deployment</a></li>
  </ul></li>
  <li><a href="#network-load-management" id="toc-network-load-management" class="nav-link" data-scroll-target="#network-load-management">Network Load Management</a>
  <ul class="collapse">
  <li><a href="#block-space-management" id="toc-block-space-management" class="nav-link" data-scroll-target="#block-space-management">Block Space Management</a></li>
  <li><a href="#transaction-scheduling" id="toc-transaction-scheduling" class="nav-link" data-scroll-target="#transaction-scheduling">Transaction Scheduling</a></li>
  </ul></li>
  <li><a href="#economic-benefits" id="toc-economic-benefits" class="nav-link" data-scroll-target="#economic-benefits">Economic Benefits</a></li>
  <li><a href="#network-evolution-through-node-voting" id="toc-network-evolution-through-node-voting" class="nav-link" data-scroll-target="#network-evolution-through-node-voting">Network Evolution Through Node Voting</a>
  <ul class="collapse">
  <li><a href="#voting-mechanism" id="toc-voting-mechanism" class="nav-link" data-scroll-target="#voting-mechanism">Voting Mechanism</a></li>
  <li><a href="#adjustment-constraints" id="toc-adjustment-constraints" class="nav-link" data-scroll-target="#adjustment-constraints">Adjustment Constraints</a></li>
  <li><a href="#example-voting-scenario" id="toc-example-voting-scenario" class="nav-link" data-scroll-target="#example-voting-scenario">Example Voting Scenario</a></li>
  <li><a href="#impact-on-resource-model" id="toc-impact-on-resource-model" class="nav-link" data-scroll-target="#impact-on-resource-model">Impact on Resource Model</a></li>
  </ul></li>
  <li><a href="#future-considerations" id="toc-future-considerations" class="nav-link" data-scroll-target="#future-considerations">Future Considerations</a></li>
  <li><a href="#conclusion" id="toc-conclusion" class="nav-link" data-scroll-target="#conclusion">Conclusion</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content"><header id="title-block-header" class="quarto-title-block"></header>




<section id="rømer-transaction-costs-and-resource-model" class="level1">
<h1>RØMER Transaction Costs and Resource Model</h1>
<p>RØMER Chain implements a comprehensive resource management system that ensures sustainable network operation through careful economic design. Our approach combines computational fees for immediate resource usage with a storage deposit system for long-term state management. This dual system creates predictable costs for users while ensuring validator sustainability.</p>
<section id="node-requirements" class="level2">
<h2 class="anchored" data-anchor-id="node-requirements">Node Requirements</h2>
<p>Every validator in the RØMER network must maintain specific hardware capabilities to ensure consistent network performance. These requirements establish the baseline for our resource calculations.</p>
<section id="hardware-requirements" class="level3">
<h3 class="anchored" data-anchor-id="hardware-requirements">Hardware Requirements</h3>
<ul>
<li>RAM: 32GB DDR4 or better</li>
<li>CPU: 8 cores (modern x86-64 processor)</li>
<li>Storage: 4TB NVMe SSD</li>
<li>Network: 1 Gbps dedicated connection</li>
</ul>
</section>
<section id="network-requirements" class="level3">
<h3 class="anchored" data-anchor-id="network-requirements">Network Requirements</h3>
<ul>
<li>Static IP address</li>
<li>Geographic distribution compliance</li>
<li>Consistent uptime monitoring</li>
<li>Performance metric reporting</li>
</ul>
</section>
</section>
<section id="computational-fee-model" class="level2">
<h2 class="anchored" data-anchor-id="computational-fee-model">Computational Fee Model</h2>
<p>Transaction fees reflect the immediate computational costs of processing operations on the network. Our model divides these costs between CPU and RAM usage, with each resource weighted according to its operational impact.</p>
<section id="cpu-resources-0.6-rømer-per-block" class="level3">
<h3 class="anchored" data-anchor-id="cpu-resources-0.6-rømer-per-block">CPU Resources (0.6 RØMER per block)</h3>
<p>CPU represents our highest-weighted computational resource due to its significant impact on node operations. Each block allows for 400 compute units, representing 50% of the total CPU capacity of our minimum node specification. This target utilization ensures consistent performance while maintaining headroom for demand spikes.</p>
<p>Base Fees:</p>
<ul>
<li>Available Units: 400 compute units per block</li>
<li>Cost Per Unit: 0.0015 RØMER</li>
<li>Total CPU Capacity: 0.6 RØMER per block</li>
</ul>
</section>
<section id="ram-resources-0.4-rømer-per-block" class="level3">
<h3 class="anchored" data-anchor-id="ram-resources-0.4-rømer-per-block">RAM Resources (0.4 RØMER per block)</h3>
<p>RAM usage forms our second computational cost component. While RAM has lower operational costs than CPU, it remains crucial for transaction processing and state management. We target 50% utilization of total RAM capacity, providing 16,384 MB per block.</p>
<p>Base Fees:</p>
<ul>
<li>Available Memory: 16,384 MB per block</li>
<li>Cost Per MB: 0.0000244140625 RØMER</li>
<li>Total RAM Capacity: 0.4 RØMER per block</li>
</ul>
</section>
<section id="computational-fee-formula" class="level3">
<h3 class="anchored" data-anchor-id="computational-fee-formula">Computational Fee Formula</h3>
<p>The total computational fee for a transaction combines its CPU and RAM usage:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>transaction_fee <span class="op">=</span> (</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># CPU Cost (0.6 RØMER base)</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    (cpu_units × <span class="fl">0.0015</span>) <span class="op">+</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    <span class="co"># RAM Cost (0.4 RØMER base)</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    (ram_mb × <span class="fl">0.0000244140625</span>)</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>) RØMER</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
</section>
<section id="storage-model" class="level2">
<h2 class="anchored" data-anchor-id="storage-model">Storage Model</h2>
<p>RØMER implements a storage deposit system that ensures sustainable state growth while providing incentives for efficient storage usage. Our model bases storage costs on the network’s 4TB minimum storage requirement, with target utilization of 50% (2TB) for active state.</p>
<section id="storage-deposits" class="level3">
<h3 class="anchored" data-anchor-id="storage-deposits">Storage Deposits</h3>
<p>When creating new objects on the blockchain, users must provide a storage deposit that remains locked until the object is deleted. This deposit is calculated based on node storage requirements and operational factors:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>storage_deposit <span class="op">=</span> (</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Header cost (10x multiplier for indexing overhead)</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    (object_header_bytes × base_byte_cost × <span class="dv">10</span>) <span class="op">+</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Content cost (base rate)</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>    (content_bytes × base_byte_cost) <span class="op">+</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Reference cost (5x multiplier for relationship maintenance)</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>    (reference_count × reference_bytes × base_byte_cost × <span class="dv">5</span>)</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>) RØMER</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The <code>base_byte_cost</code> reflects:</p>
<ul>
<li>4TB minimum storage requirement</li>
<li>50% target utilization (2TB)</li>
<li>Hardware lifetime (estimated 1 year)</li>
<li>Replication factor (3x for redundancy)</li>
<li>Maintenance overhead (1.5x multiplier)</li>
</ul>
</section>
<section id="storage-rebates" class="level3">
<h3 class="anchored" data-anchor-id="storage-rebates">Storage Rebates</h3>
<p>When objects are deleted from the blockchain, 90% of the original storage deposit is returned to the user who originally paid for storage. The remaining 10% is awarded to the validator who processes the deletion, creating an incentive for timely cleanup of unused state.</p>
</section>
</section>
<section id="example-operation-costs" class="level2">
<h2 class="anchored" data-anchor-id="example-operation-costs">Example Operation Costs</h2>
<p>Let’s examine the total costs for common operations on the RØMER network.</p>
<section id="simple-token-transfer" class="level3">
<h3 class="anchored" data-anchor-id="simple-token-transfer">Simple Token Transfer</h3>
<p>Computational Resources:</p>
<ul>
<li>RAM: 10MB (0.000244 RØMER)</li>
<li>CPU: 2 compute units (0.003 RØMER)</li>
</ul>
<p>Computation Fee: 0.003244 RØMER</p>
<p>Storage Impact: None (modifies existing state) Total Cost: 0.003244 RØMER</p>
</section>
<section id="nft-mint-operation" class="level3">
<h3 class="anchored" data-anchor-id="nft-mint-operation">NFT Mint Operation</h3>
<p>Computational Resources:</p>
<ul>
<li>RAM: 500MB (0.012207 RØMER)</li>
<li>CPU: 15 compute units (0.0225 RØMER)</li>
</ul>
<p>Computation Fee: 0.034707 RØMER</p>
<p>Storage Resources:</p>
<ul>
<li>Object Header: 32 bytes</li>
<li>Content: 1000 bytes</li>
<li>References: 2</li>
</ul>
<p>Storage Deposit: [calculated based on base_byte_cost] Total Cost: Computation Fee + Storage Deposit</p>
</section>
<section id="smart-contract-deployment" class="level3">
<h3 class="anchored" data-anchor-id="smart-contract-deployment">Smart Contract Deployment</h3>
<p>Computational Resources:</p>
<ul>
<li>RAM: 1,000MB (0.024414 RØMER)</li>
<li>CPU: 100 compute units (0.15 RØMER)</li>
</ul>
<p>Computation Fee: 0.174414 RØMER</p>
<p>Storage Resources:</p>
<ul>
<li>Object Header: 32 bytes</li>
<li>Content: ~10,000 bytes (typical contract)</li>
<li>References: 5</li>
</ul>
<p>Storage Deposit: [calculated based on base_byte_cost] Total Cost: Computation Fee + Storage Deposit</p>
</section>
</section>
<section id="network-load-management" class="level2">
<h2 class="anchored" data-anchor-id="network-load-management">Network Load Management</h2>
<p>RØMER manages high demand through block scheduling rather than variable fees. This approach ensures predictable costs while maintaining network stability.</p>
<section id="block-space-management" class="level3">
<h3 class="anchored" data-anchor-id="block-space-management">Block Space Management</h3>
<ul>
<li>Target utilization: 50% of resources</li>
<li>Maximum utilization: 80% of resources</li>
<li>Excess transactions queue for future blocks</li>
<li>No fee increases during high demand</li>
</ul>
</section>
<section id="transaction-scheduling" class="level3">
<h3 class="anchored" data-anchor-id="transaction-scheduling">Transaction Scheduling</h3>
<p>The network prioritizes transactions based on:</p>
<ul>
<li>Time in mempool</li>
<li>Resource availability</li>
<li>Dependencies</li>
<li>Storage operation balance</li>
</ul>
</section>
</section>
<section id="economic-benefits" class="level2">
<h2 class="anchored" data-anchor-id="economic-benefits">Economic Benefits</h2>
<p>Our resource model creates several key advantages for network participants:</p>
<p>For Users:</p>
<ul>
<li>Predictable transaction costs</li>
<li>Recoverable storage deposits</li>
<li>Fair resource pricing</li>
<li>No fee market volatility</li>
</ul>
<p>For Developers:</p>
<ul>
<li>Clear cost estimation</li>
<li>Predictable application economics</li>
<li>Resource optimization incentives</li>
<li>Sustainable state management</li>
</ul>
<p>For Validators:</p>
<ul>
<li>Sustainable node economics</li>
<li>Multiple revenue streams</li>
<li>Clear capacity planning</li>
<li>Predictable resource usage</li>
</ul>
</section>
<section id="network-evolution-through-node-voting" class="level2">
<h2 class="anchored" data-anchor-id="network-evolution-through-node-voting">Network Evolution Through Node Voting</h2>
<p>RØMER implements a democratic mechanism for adjusting minimum node requirements through validator voting. This process allows the network to naturally evolve with technological advancement while maintaining decentralized governance.</p>
<section id="voting-mechanism" class="level3">
<h3 class="anchored" data-anchor-id="voting-mechanism">Voting Mechanism</h3>
<p>Node operators can propose and vote on adjustments to minimum requirements in any of these dimensions:</p>
<ul>
<li>RAM capacity</li>
<li>CPU cores and speed</li>
<li>Storage capacity</li>
<li>Network bandwidth</li>
<li>Geographic distribution parameters</li>
</ul>
<p>The voting process follows these principles:</p>
<ol type="1">
<li><p>Proposal Threshold A proposal to adjust minimum requirements must be supported by at least 5% of active validators to enter the voting phase.</p></li>
<li><p>Voting Period Each proposal has a voting period of 10,000 blocks (approximately 3.5 days with 30-second blocks), giving all validators time to participate.</p></li>
<li><p>Gradual Implementation Approved changes take effect after a 30-day grace period, allowing operators to upgrade their hardware if necessary.</p></li>
<li><p>Vote Weighting Each validator gets one vote, regardless of their hardware specifications. This ensures that larger operators cannot dominate the governance process.</p></li>
<li><p>Passage Requirements A proposal must meet these criteria to pass:</p></li>
</ol>
<ul>
<li>Over 67% participation from active validators</li>
<li>Over 75% approval from voting validators</li>
<li>No more than 30% increase in any single requirement</li>
</ul>
</section>
<section id="adjustment-constraints" class="level3">
<h3 class="anchored" data-anchor-id="adjustment-constraints">Adjustment Constraints</h3>
<p>To maintain network stability, several constraints apply to requirement adjustments:</p>
<ol type="1">
<li>Timing Restrictions</li>
</ol>
<ul>
<li>Minimum 90 days between successful requirement changes</li>
<li>Maximum one active proposal per resource type</li>
<li>Grace period cannot be shortened</li>
</ul>
<ol start="2" type="1">
<li>Size Limitations</li>
</ol>
<ul>
<li>Maximum 30% increase per vote</li>
<li>No more than 100% total increase per year</li>
<li>Cannot decrease requirements</li>
</ul>
<ol start="3" type="1">
<li>Technical Validations</li>
</ol>
<ul>
<li>RAM must be standard sizes (e.g., 32GB, 64GB)</li>
<li>Storage must be practical configurations</li>
<li>CPU requirements must align with available hardware</li>
</ul>
</section>
<section id="example-voting-scenario" class="level3">
<h3 class="anchored" data-anchor-id="example-voting-scenario">Example Voting Scenario</h3>
<p>Consider a proposal to increase minimum RAM from 32GB to 64GB:</p>
<ol type="1">
<li>Initial Phase</li>
</ol>
<ul>
<li>Validators running 64GB+ RAM notice increased state size</li>
<li>Proposal created with support from 5% of validators</li>
<li>Voting period begins</li>
</ul>
<ol start="2" type="1">
<li>Voting Process</li>
</ol>
<ul>
<li>Validators evaluate impact on their operations</li>
<li>Community discusses hardware availability and costs</li>
<li>Real-time voting progress visible to all participants</li>
</ul>
<ol start="3" type="1">
<li>Implementation If approved:</li>
</ol>
<ul>
<li>30-day grace period begins</li>
<li>Operators prepare hardware upgrades</li>
<li>Network clients update requirement checks</li>
<li>New requirements take effect at specified block height</li>
</ul>
</section>
<section id="impact-on-resource-model" class="level3">
<h3 class="anchored" data-anchor-id="impact-on-resource-model">Impact on Resource Model</h3>
<p>When minimum requirements change, the fee model automatically adjusts because all resource costs are calculated as fractions of total capacity. For example, if RAM requirements double:</p>
<ol type="1">
<li>Block Capacity</li>
</ol>
<ul>
<li>New target RAM per block: 32GB (50% of 64GB)</li>
<li>Computational units scale proportionally</li>
<li>Storage capacity adjusts with new minimums</li>
</ul>
<ol start="2" type="1">
<li>Fee Adjustments</li>
</ol>
<ul>
<li>Per-unit costs adjust automatically</li>
<li>Overall economic model remains stable</li>
<li>User costs effectively decrease as capacity increases</li>
</ul>
<ol start="3" type="1">
<li>Network Benefits</li>
</ol>
<ul>
<li>Increased transaction throughput</li>
<li>Better state management capability</li>
<li>Improved performance for complex operations</li>
<li>Future-proofing for network growth</li>
</ul>
</section>
</section>
<section id="future-considerations" class="level2">
<h2 class="anchored" data-anchor-id="future-considerations">Future Considerations</h2>
<p>This governance model ensures RØMER can evolve while maintaining its core principles:</p>
<ol type="1">
<li>Technological Evolution</li>
</ol>
<ul>
<li>Requirements track hardware advancement</li>
<li>Network capacity grows organically</li>
<li>Performance improves systematically</li>
<li>Costs optimize naturally</li>
</ul>
<ol start="2" type="1">
<li>Economic Stability</li>
</ol>
<ul>
<li>Resource pricing remains predictable</li>
<li>Node operations stay sustainable</li>
<li>User costs scale with technology</li>
<li>Market forces guide growth</li>
</ul>
<ol start="3" type="1">
<li>Decentralized Control</li>
</ol>
<ul>
<li>Community-driven evolution</li>
<li>Democratic decision making</li>
<li>Protected minority interests</li>
<li>Stable upgrade path</li>
</ul>
</section>
<section id="conclusion" class="level2">
<h2 class="anchored" data-anchor-id="conclusion">Conclusion</h2>
<p>RØMER’s resource model creates a sustainable economic framework that aligns the interests of all network participants. By combining fixed computational fees with a storage deposit system, we ensure both efficient immediate resource usage and responsible long-term state growth. This approach provides the predictability users need while maintaining the economic incentives required for network sustainability.</p>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>